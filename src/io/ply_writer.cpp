#include "gf/io/ply.h"

#include "gf/io/writer.h"

#include <cstdint>
#include <sstream>
#include <string>
#include <vector>

#include "gf/core/errors.h"
#include "gf/core/gauss_ir.h"
#include "gf/core/validate.h"

namespace gf {

class PlyWriter : public IGaussWriter {
public:
  Expected<std::vector<uint8_t>> Write(const GaussianCloudIR &ir,
                                       const WriteOptions &options) override {
    const auto err = ValidateBasic(ir, options.strict);
    if (!err.message.empty() && options.strict)
      return Expected<std::vector<uint8_t>>(err);

    const int32_t N = ir.numPoints;
    if (N == 0) {
      std::vector<uint8_t> empty;
      return Expected<std::vector<uint8_t>>(std::move(empty));
    }

    const int coeffs_per_point =
        ShCoeffsPerPoint(ir.meta.shDegree); // = shDim * 3
    const int shDim = coeffs_per_point / 3;
    const int32_t D = 17 + shDim * 3;

    std::vector<float> values(static_cast<size_t>(N) * D, 0.0f);
    int outIdx = 0, i3 = 0, i4 = 0;
    for (int32_t i = 0; i < N; i++) {
      // Position (x, y, z)
      values[outIdx++] = ir.positions[i3 + 0];
      values[outIdx++] = ir.positions[i3 + 1];
      values[outIdx++] = ir.positions[i3 + 2];
      // Normals (nx, ny, nz) zeros
      values[outIdx++] = 0.0f;
      values[outIdx++] = 0.0f;
      values[outIdx++] = 0.0f;
      // Color DC
      values[outIdx++] = ir.colors[i3 + 0];
      values[outIdx++] = ir.colors[i3 + 1];
      values[outIdx++] = ir.colors[i3 + 2];
      // SH R
      for (int j = 0; j < shDim; j++) {
        values[outIdx++] = ir.sh[(i * shDim + j) * 3 + 0];
      }
      // SH G
      for (int j = 0; j < shDim; j++) {
        values[outIdx++] = ir.sh[(i * shDim + j) * 3 + 1];
      }
      // SH B
      for (int j = 0; j < shDim; j++) {
        values[outIdx++] = ir.sh[(i * shDim + j) * 3 + 2];
      }
      // Alpha (pre-sigmoid)
      values[outIdx++] = ir.alphas[i];
      // Scale (sx, sy, sz) log-scale
      values[outIdx++] = ir.scales[i3 + 0];
      values[outIdx++] = ir.scales[i3 + 1];
      values[outIdx++] = ir.scales[i3 + 2];
      // Rotation (rot_0 = w, rot_1/2/3 = x/y/z)
      values[outIdx++] = ir.rotations[i4 + 0];
      values[outIdx++] = ir.rotations[i4 + 1];
      values[outIdx++] = ir.rotations[i4 + 2];
      values[outIdx++] = ir.rotations[i4 + 3];
      i3 += 3;
      i4 += 4;
    }

    // Build output buffer
    std::ostringstream header;
    header << "ply\n";
    header << "format binary_little_endian 1.0\n";
    header << "comment generated by gauss_forge\n";
    header << "element vertex " << N << "\n";
    header << "property float x\n";
    header << "property float y\n";
    header << "property float z\n";
    header << "property float nx\n";
    header << "property float ny\n";
    header << "property float nz\n";
    header << "property float f_dc_0\n";
    header << "property float f_dc_1\n";
    header << "property float f_dc_2\n";
    for (int i = 0; i < shDim * 3; i++) {
      header << "property float f_rest_" << i << "\n";
    }
    header << "property float opacity\n";
    header << "property float scale_0\n";
    header << "property float scale_1\n";
    header << "property float scale_2\n";
    header << "property float rot_0\n";
    header << "property float rot_1\n";
    header << "property float rot_2\n";
    header << "property float rot_3\n";
    header << "end_header\n";

    std::string headerStr = header.str();
    std::vector<uint8_t> result;
    result.reserve(headerStr.size() + values.size() * sizeof(float));
    result.insert(result.end(), headerStr.begin(), headerStr.end());
    const uint8_t *dataPtr = reinterpret_cast<const uint8_t *>(values.data());
    result.insert(result.end(), dataPtr,
                  dataPtr + values.size() * sizeof(float));

    return Expected<std::vector<uint8_t>>(std::move(result));
  }
};

std::unique_ptr<IGaussWriter> MakePlyWriter() {
  return std::make_unique<PlyWriter>();
}

} // namespace gf
