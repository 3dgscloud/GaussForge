#include "gf/io/ply.h"

#include "gf/io/writer.h"

#include <algorithm>
#include <cmath>
#include <cstdint>
#include <cstring>
#include <fstream>
#include <iostream>
#include <memory>
#include <sstream>
#include <string>
#include <vector>

#include "gf/core/errors.h"
#include "gf/core/gauss_ir.h"
#include "gf/core/validate.h"

namespace gf {

namespace {

// Build PLY header string
std::string BuildHeader(int32_t N, int shDim) {
  std::ostringstream header;
  header << "ply\n";
  header << "format binary_little_endian 1.0\n";
  header << "comment Generated by GaussForge\n";
  header << "element vertex " << N << "\n";
  header << "property float x\n";
  header << "property float y\n";
  header << "property float z\n";
  header << "property float nx\n";
  header << "property float ny\n";
  header << "property float nz\n";
  header << "property float f_dc_0\n";
  header << "property float f_dc_1\n";
  header << "property float f_dc_2\n";
  for (int i = 0; i < shDim * 3; i++) {
    header << "property float f_rest_" << i << "\n";
  }
  header << "property float opacity\n";
  header << "property float scale_0\n";
  header << "property float scale_1\n";
  header << "property float scale_2\n";
  header << "property float rot_0\n";
  header << "property float rot_1\n";
  header << "property float rot_2\n";
  header << "property float rot_3\n";
  header << "end_header\n";
  return header.str();
}

} // anonymous namespace

class PlyWriter : public IGaussWriter {
public:
  Expected<std::vector<uint8_t>> Write(const GaussianCloudIR &ir,
                                       const WriteOptions &options) override {
    // 1. Basic validation
    const auto err = ValidateBasic(ir, options.strict);
    if (!err.message.empty() && options.strict)
      return Expected<std::vector<uint8_t>>(err);

    const int32_t N = ir.numPoints;
    if (N == 0) {
      std::vector<uint8_t> empty;
      return Expected<std::vector<uint8_t>>(std::move(empty));
    }

    const int coeffs_per_point = ShCoeffsPerPoint(ir.meta.shDegree);
    const int shDim = coeffs_per_point / 3;
    const int32_t D = 17 + shDim * 3;

    // Calculate final size and allocate result container in one go
    std::string headerStr = BuildHeader(N, shDim);
    const size_t headerSize = headerStr.size();
    const size_t dataSize = static_cast<size_t>(N) * D * sizeof(float);

    // Allocate result buffer
    std::vector<uint8_t> result;
    result.resize(headerSize + dataSize);

    // Write header (using memcpy is more efficient)
    std::memcpy(result.data(), headerStr.data(), headerSize);

    float *__restrict__ outBase =
        reinterpret_cast<float *>(result.data() + headerSize);

    const float *__restrict__ posBase = ir.positions.data();
    const float *__restrict__ colorBase = ir.colors.data();
    const float *__restrict__ shBase = ir.sh.data();
    const float *__restrict__ alphaBase = ir.alphas.data();
    const float *__restrict__ scaleBase = ir.scales.data();
    const float *__restrict__ rotBase = ir.rotations.data();

    for (int32_t i = 0; i < N; i++) {
      const size_t outIdx = static_cast<size_t>(i) * D;
      float *__restrict__ out = outBase + outIdx;

      const int i3 = i * 3;
      const int i4 = i * 4;

      // Position (x, y, z)
      out[0] = posBase[i3 + 0];
      out[1] = posBase[i3 + 1];
      out[2] = posBase[i3 + 2];

      // Normals (nx, ny, nz) zeros
      out[3] = 0.0f;
      out[4] = 0.0f;
      out[5] = 0.0f;

      // Color DC
      out[6] = colorBase[i3 + 0];
      out[7] = colorBase[i3 + 1];
      out[8] = colorBase[i3 + 2];

      // SH coefficients: R, then G, then B
      int outOffset = 9;
      for (int j = 0; j < shDim; j++) {
        out[outOffset + j] = shBase[(i * shDim + j) * 3 + 0]; // SH R
      }
      outOffset += shDim;
      for (int j = 0; j < shDim; j++) {
        out[outOffset + j] = shBase[(i * shDim + j) * 3 + 1]; // SH G
      }
      outOffset += shDim;
      for (int j = 0; j < shDim; j++) {
        out[outOffset + j] = shBase[(i * shDim + j) * 3 + 2]; // SH B
      }
      outOffset += shDim;

      // Alpha (pre-sigmoid)
      out[outOffset++] = alphaBase[i];

      // Scale (sx, sy, sz) log-scale
      out[outOffset++] = scaleBase[i3 + 0];
      out[outOffset++] = scaleBase[i3 + 1];
      out[outOffset++] = scaleBase[i3 + 2];

      // Rotation (rot_0 = w, rot_1/2/3 = x/y/z)
      out[outOffset++] = rotBase[i4 + 0];
      out[outOffset++] = rotBase[i4 + 1];
      out[outOffset++] = rotBase[i4 + 2];
      out[outOffset++] = rotBase[i4 + 3];
    }

    return Expected<std::vector<uint8_t>>(std::move(result));
  }
};

std::unique_ptr<IGaussWriter> MakePlyWriter() {
  return std::make_unique<PlyWriter>();
}

} // namespace gf
